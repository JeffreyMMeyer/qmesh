<html>



<head></head>

<body>


<div class="left">
	<h4>Tile information:</h4>
	<div id="tile-header-content"></div>
</div>

<div class="right">
	<div id="three"></div>

</div>
            
<script type="text/template" id="tile-header-template">
<div class="tile-header">
    Center x: <%= centerX %> m<br>
    Center y: <%= centerY %> m<br>
    Center z: <%= centerZ %> m<br>

    <h6>Tile heights</h6>
    Maximum: <%= maximumHeight %> m<br>
    Minimum: <%= minimumHeight %> m<br>

    <h6>Bounding Sphere</h6>
    Center x: <%= boundingSphereCenterX  %><br>
    Center y: <%= boundingSphereCenterY %><br>
    Center z: <%= boundingSphereCenterZ %><br>
    Radius: <%= boundingSphereRadius %><br>

</div>

</script>


	


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.2.3/backbone.js"></script>
<script type="text/javascript" src= "https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>

	<script>
	var UINT16_BYTE_SIZE = 2;
	var UINT32_BYTE_SIZE = 4;
	var FLOAT64_BYTE_SIZE = 8;
	var FLOAT32_BYTE_SIZE = 4;

	var url = "http://assets.agi.com/stk-terrain/world/12/1566/2762.terrain?v=1.16389.0";
	var xtile = 2762;
	var ytile = 1566;
	var zoom = 12;
	var nw = getTileBounds(xtile, ytile, zoom);
	var se = getTileBounds(xtile+1, ytile+1, zoom);
	console.log(nw, se);
    var headerTemplate = _.template( $('#tile-header-template').html());
	function getRequest() {
		var xhr = new XMLHttpRequest();
		
		xhr.onload = function(e) {
			parseQuantizedMeshTile(this.response);
	  	}
		xhr.open('GET', '../3452.terrain', true);
		// xhr.open('GET', url, true);
		xhr.send(null);
		xhr.responseType = "arraybuffer";
 	}

 	function parseQuantizedMeshTile(data, x, y, z) {
		var byteCount = 0;
		var length = data.byteLength;

		var qtile = {};
 		
 		var header = getHeader(data, byteCount);
		byteCount += 88;


		var vertexCount = getUint32(data, byteCount);
		byteCount += UINT32_BYTE_SIZE;

		var uArray = getUint16Array(data, byteCount, vertexCount);
		byteCount += vertexCount * UINT16_BYTE_SIZE;

		var vArray = getUint16Array(data, byteCount, vertexCount);
		byteCount += vertexCount * UINT16_BYTE_SIZE;

		var heightArray = getUint16Array(data, byteCount, vertexCount);
		byteCount += vertexCount * UINT16_BYTE_SIZE;


        var i;
        var u = 0;
        var v = 0;
        var height = 0;
        function zigZagDecode(value) {
            return (value >> 1) ^ (-(value & 1));
        }
        for (i = 0; i < vertexCount; ++i) {
            u += zigZagDecode(uArray[i]);
            v += zigZagDecode(vArray[i]);
            height += zigZagDecode(heightArray[i]);
            uArray[i] = u;
            vArray[i] = v;
            heightArray[i] = height;
        }
 		if (byteCount % 2 !== 0) {
            byteCount += (2 - (byteCount % 2));
        }
        var triangleCount = getUint32(data, byteCount);
        byteCount += UINT32_BYTE_SIZE;
        
	    console.log("triangleCount", triangleCount);
	    console.log("vertexCount", vertexCount);

		var indices = getUint16(data, byteCount, triangleCount);
		byteCount += triangleCount * 3 * 2;
		var highest = 0;
        for (i = 0; i < indices.length; ++i) {
            var code = indices[i];
            indices[i] = highest - code;
            if (code === 0) {
                ++highest;
            }
        }
        
        var westVertexCount = getUint32(data,byteCount);
        byteCount += UINT32_BYTE_SIZE;
        var westIndices = getUint16Array(data,byteCount,westVertexCount);
        byteCount += UINT16_BYTE_SIZE * westVertexCount;

		var southVertexCount= getUint32(data, byteCount);
        byteCount += UINT32_BYTE_SIZE;
        var southIndices = getUint16Array(data, byteCount, southVertexCount);
        byteCount += UINT16_BYTE_SIZE * southVertexCount;
		
		var eastVertexCount = getUint32(data, byteCount);
        byteCount += UINT32_BYTE_SIZE;
        var eastIndices = getUint16Array(data, byteCount, eastVertexCount);
        byteCount += UINT16_BYTE_SIZE * eastVertexCount;
        
        var northVertexCount = getUint32(data, byteCount);
        byteCount += UINT32_BYTE_SIZE;
        var northIndices = getUint16Array(data, byteCount, northVertexCount);
        byteCount += UINT16_BYTE_SIZE * northVertexCount;
        
        console.log (westVertexCount, eastVertexCount, southVertexCount, northVertexCount);



        $('#tile-header-content').append($(headerTemplate(header)));

        visualize(vertices, indices);
 	}
 	function buildVertices(geometry, maxLL, minLL, u, v, heights) {
 		for (var i = 0; i < u.length; i++) {
 			geometry.vertices.push(new THREE.Vertex3());
 		}
 	}

 	function visualize(u, v, heights, indices) {


 		var geometry = new THREE.Geometry();

 		for (var i = 0; i < vertices.length; i++) {
 			geometry.vertices.push(new THREE.Vertex3())
 		}

 		for (var i = 0; i < indices.length; i+=3) {
			geometry.faces.push(new THREE.Face3(, upper_right, upper_left));	
				
 		}

 	}


    function zigZagDecode(value) {
    	// REF CESIUM SOURCE CODE
        return (value >> 1) ^ (-(value & 1));
    }
 	function getHeader(data, byteCount) {

		return {
			centerX : getFloat64(data, byteCount),
		    centerY : getFloat64(data, byteCount + 8),
		    centerZ : getFloat64(data, byteCount + 16),
		    minimumHeight : getFloat32(data, byteCount + 24),
		    maximumHeight : getFloat32(data, byteCount + 28),
		    boundingSphereCenterX : getFloat64(data, byteCount + 32),
		    boundingSphereCenterY : getFloat64(data, byteCount + 40),
		    boundingSphereCenterZ : getFloat64(data, byteCount + 48),
		    boundingSphereRadius : getFloat64(data, byteCount + 56),
		    horizonOcclusionPointX : getFloat64(data, byteCount + 64),
		    horizonOcclusionPointY : getFloat64(data, byteCount + 72),
		    horizonOcclusionPointZ : getFloat64(data, byteCount + 80)
		}
 	}
 	function getVertexCount(data, byteCount) {
 		var int16View = new Uint16Array(data.slice(byteCount, byteCount+=2));
 		return int16View[0];
	}
 	function getTileBounds(tx, ty, zoom) {
 		//http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Tile_numbers_to_lon..2Flat.
		var n = Math.pow(2, zoom);
		var lon_deg = tx / n * 360.0 -180.0;
		var lat_rad = Math.atan(Math.sinh(Math.PI * (1 - 2 * ty / n)));
		var lat_deg = lat_rad * 180.0 / Math.PI;
		return { lon: lon_deg, lat: lat_deg};
 	}
 	function getUint32Array(data, startPos, count) {
 		return new Uint32Array(data.slice(startPos, startPos + 4*count));
 	}
 	function getUint32(data, startPos) {
 		return getUint32Array(data, startPos, 1)[0];
 	}
 	function getUint16Array(data, startPos, count) {
 		return new Uint16Array(data.slice(startPos, startPos + 2*count));
 	}
 	function getUint16(data, startPos) {
 		return getUint16Array(data, startPos, 1)[0];
 	}
 	function getFloat64Array(data, startPos, count) {
 		return new Float64Array(data.slice(startPos, startPos + 8 * count));
 	}
 	function getFloat64(data, startPos) {
 		return getFloat64Array(data, startPos, 1)[0]; 		
 	}
 	function getFloat32Array(data, startPos, count) {
 		return new Float32Array(data.slice(startPos, startPos + 4*count));
 	}
 	function getFloat32(data, startPos) {
 		return getFloat32Array(data, startPos, 1)[0]; 		
 	}


 	function getFloat64o(d) {
 		var f64 = new Float64Array(d);
 		return f64[0];
 	}


 	function handle(data) {
 		var byteCount = 0;
		var length = new Uint8Array(data).length;
			// var uint8 = new Uint8Array(data.slice(byteCount,byteCount++)); // Endianness
				
 	}
getRequest();
</script>


</body>


</html>